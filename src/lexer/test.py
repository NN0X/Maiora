# This script was generated by ChatGPT based on user instructions.
# As such it is not under terms noted in NOTICE and LICENSING

import re
import subprocess
import sys
from pathlib import Path
import difflib
import os

def reconstruct_code_from_tokens(token_dump_path):
    """
    Fully 1:1 reconstruction of original code from token dump.
    Preserves spaces, semicolons, and newlines exactly as encoded in line/pos data.
    Assumes pos is 1-indexed in token dump.
    Returns reconstructed code as string.
    """
    token_pattern = re.compile(
        r'^(Token|SPACE_STUB|STR_STUB)\s+\d+:\s*\|\s*(.*?)\s*\|\s*line:\s*(\d+)\s*\|\s*pos:\s*(\d+)'
    )

    lines = {}

    with open(token_dump_path, "r", encoding="utf-8") as f:
        for raw_line in f:
            match = token_pattern.match(raw_line)
            if not match:
                continue

            kind, value, line_str, pos_str = match.groups()
            line = int(line_str)
            pos = int(pos_str) - 1  # Convert 1-indexed to 0-indexed

            if line not in lines:
                lines[line] = {}

            # Handle token values
            if kind == "SPACE_STUB":
                token_value = " "
            elif value == "TOK_OP_SEMICOLON":
                token_value = ";"
            else:
                token_value = value

            lines[line][pos] = token_value

    max_line = max(lines.keys(), default=0)
    output_lines = []

    for ln in range(1, max_line + 1):
        if ln not in lines:
            output_lines.append("")
            continue

        tokens_sorted = sorted(lines[ln].items())
        reconstructed_line = ""
        current_pos = 0
        for pos, text in tokens_sorted:
            if pos > current_pos:
                reconstructed_line += " " * (pos - current_pos)
            reconstructed_line += text
            current_pos = pos + len(text)

        output_lines.append(reconstructed_line)

    code = "\n".join(output_lines)
    return code.rstrip("\n")  # Ignore trailing newlines at the end

def compare_files(original_code, reconstructed_code):
    """
    Compares two strings line by line and prints differences.
    Ignores trailing newlines.
    """
    original_lines = original_code.rstrip("\n").splitlines()
    reconstructed_lines = reconstructed_code.rstrip("\n").splitlines()
    diff = list(difflib.unified_diff(original_lines, reconstructed_lines,
                                     fromfile="original", tofile="reconstructed", lineterm=""))
    if diff:
        print("❌ Differences found:")
        for line in diff:
            print(line)
        return False
    else:
        print("✅ No differences found. Reconstruction matches original exactly!")
        return True

def main():
    if len(sys.argv) != 2:
        print(f"Usage: python {sys.argv[0]} <input_file>")
        sys.exit(1)

    input_file = Path(sys.argv[1])
    if not input_file.exists():
        print(f"Error: {input_file} does not exist.")
        sys.exit(1)

    # Run ./main <input_file> 1
    result = subprocess.run(["./main", str(input_file), "1"], capture_output=True, text=True)
    if result.returncode != 0:
        print("Error: ./main execution failed")
        print(result.stderr)
        sys.exit(1)

    # Write token dump to file
    token_dump_path = "token_dump.log"
    with open(token_dump_path, "w", encoding="utf-8") as f:
        f.write(result.stdout)

    # Reconstruct code from token dump
    reconstructed_code = reconstruct_code_from_tokens(token_dump_path)

    # Read original code
    with open(input_file, "r", encoding="utf-8") as f:
        original_code = f.read()

    # Compare
    matched = compare_files(original_code, reconstructed_code)

    # Optional: save reconstructed file
    reconstructed_path = "reconstructed.txt"
    with open(reconstructed_path, "w", encoding="utf-8") as f:
        f.write(reconstructed_code)

    if matched:
        # Delete created files if no differences
        os.remove(token_dump_path)
        os.remove(reconstructed_path)
    else:
        print(f"✅ Reconstructed source saved to {reconstructed_path}")

if __name__ == "__main__":
    main()

